@prefix : <http://www.semanticweb.org/ivans/ontologies/2025/instance-model-1#>.
@prefix meta: <http://www.semanticweb.org/ivans/ontologies/2025/ruleless-digital-twins/>.
@prefix ssn: <http://www.w3.org/ns/ssn/>.
@prefix sosa: <http://www.w3.org/ns/sosa/>.
@include <verification-rules.rules>.
@include <user-rules.rules>.



// For performance reasons, we`re not making an intermediate OWL inference step. At times, these might be necessary to reduce
// rule writing, so we make a manual inference saying OptimalCondition (subclass) individuals are also of type Condition (superclass). 
[rule1a:    (?optimalCondition rdf:type meta:OptimalCondition)
            ->  (?optimalCondition rdf:type meta:Condition)
]



// Upon locating the marks for Condition constraints, these rules find the relevant PropertyChanges and use them as a temporary mark
// for subsequent rules.

[rule1b:    (?aNode :withCondition ?condition)
            (?aNode :withConditionProperty ?conditionProperty)
            (?conditionProperty meta:hasValue ?conditionPropertyValue)
            (?aNode owl:hasValue ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?aNode owl:onProperty ?operator)
            noValue(?aNode :withCheck "conjunction")
            equal(?operator, meta:equalTo)
            ->  print(?conditionPropertyValue)
                print(?boundPropertyValue)
]

// single constraint, no conjunction (disjunctive constraints can be treated as single here) markers
// conjunctive constraint, equal to and equal to different bounds
// conjunctive constraint, equal to and equal to the same bound, only if values in valid ranges
// conjunctive constraint, equal to and less than or equal to different bounds
// conjunctive constraint, equal to and less than or equal to the same bound, only if values in valid ranges
// conjunctive constraint, equal to and greater than or equal to different bounds
// conjunctive constraint, equal to and greater than or equal to the same bound, only if values in valid ranges
// conjunctive constraint, greater than and less than different bounds, only if values in valid ranges
// conjunctive constraint, greater than and less than or equal to different bounds, only if values in valid ranges
// conjunctive constraint, greater than or equal to and less than different bounds, only if values in valid ranges
// conjunctive constraint, greater than or equal to and less than or equal to bounds, only if values in valid ranges



// The following rules locate PropertyChange marks and generate appropriate Actions, either with Actuators or ConfigurableParameters. URI
// concatinations are used for generating unique names for unique combinations of elements in an Action. This ensures that no duplicate Actions
// are generated in cases of, e.g., multiple actuators causing multiple different PropertyChanges.

[rule3a:   (?thing :withPropertyChange ?propertyChange)
           (?actuator meta:enacts ?propertyChange)
           (?actuator rdf:type sosa:Actuator)
           (?actuator meta:hasActuatorState ?actuatorState)
           uriConcat(?actuator, "_", ?actuatorState, ?actionName)
           ->  (?actionName rdf:type meta:ActuationAction)
               (?actionName meta:hasActuator ?actuator)
               (?actionName meta:hasActuatorState ?actuatorState)
               print()
               print("Generated ActuationAction", ?actionName)
               print()
]

[rule3b:   (?thing :withPropertyChange ?propertyChange)
           (?configurableParameter meta:enacts ?propertyChange)
           (?configurableParameter rdf:type meta:ConfigurableParameter)
           (?configurableParameter meta:hasPossibleValue ?configurableParameterValue)
           uriConcat(?configurableParameter, "_", ?configurableParameterValue, ?actionName)
           ->  (?actionName rdf:type meta:ReconfigurationAction)
               (?actionName ssn:forProperty ?configurableParameter)
               (?actionName meta:hasValue ?configurableParameterValue)
               print()
               print("Generated ReconfigurationAction", ?actionName)
               print()
]

// The following rules generate Actions provided the switch for generating restrictive combinations (only based on unsatisfied OptimalConditions)
// is disabled.

[rule3c:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "false"^^xsd:boolean)
            (?actuator rdf:type sosa:Actuator)
            (?actuator meta:hasActuatorState ?actuatorState)
            uriConcat(?actuator, "_", ?actuatorState, ?actionName)
            ->  (?actionName rdf:type meta:ActuationAction)
                (?actionName meta:hasActuator ?actuator)
                (?actionName meta:hasActuatorState ?actuatorState)
                print()
                print("Generated ActuationAction", ?actionName)
                print()
]

[rule3d:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "false"^^xsd:boolean)
            (?configurableParameter rdf:type meta:ConfigurableParameter)
            (?configurableParameter meta:hasPossibleValue ?configurableParameterValue)
            uriConcat(?configurableParameter, "_", ?configurableParameterValue, ?actionName)
            ->  (?actionName rdf:type meta:ReconfigurationAction)
                (?actionName ssn:forProperty ?configurableParameter)
                (?actionName meta:hasValue ?configurableParameterValue)
                print()
                print("Generated ReconfigurationAction", ?actionName)
                print()
]



// The following rules infer possible combinations of Actions to take as part of the DT`s final decision. They effectively produce a
// cartesian product of a variable number of sets (Actions grouped by Actuators or ConfigurableParameters) with a variable number of
// elements (possible Actuator states or ConfigurableParameter values).
//
// The rules work by initially creating an ActionCombination for each Action found in the model (rules 4a and 4b). Every ActionCombination
// contains an rdf:List of Actions, which it then expands as it encounters new ones (rules 4c and 4d). To be added to the list, these Actions
// must not already be contained in it and their Actuators/ConfigurableParameters must not be the same as those of other Actions already
// in it. Because this method generates permutations (lists of the same Actions in different orders), additional rules (rules 4e and 4f)
// are necessary to eliminate duplicates and reduce the combinatorial explosion.
//
// In the end, all ActionCombinations that are NOT marked with "duplicate" (same combination already exists) or "not final" (the combination
// contains fewer Actions than it should) are final.

[rule4a:    (?actuationAction rdf:type meta:ActuationAction)
            (?actuationAction meta:hasActuator ?actuator)
            makeTemp(?actionCombination)
            makeTemp(?actionList)
            makeTemp(?actuatorList)
            ->  (?actionCombination rdf:type meta:ActionCombination)
                (?actionCombination meta:hasActions ?actionList)
                (?actionList rdf:type rdf:List)
                (?actionList rdf:first ?actuationAction)
                (?actionList rdf:rest rdf:nil)
                (?actionCombination meta:hasActuators ?actuatorList)
                (?actuatorList rdf:type rdf:List)
                (?actuatorList rdf:first ?actuator)
                (?actuatorList rdf:rest rdf:nil)
]

[rule4b:    (?reconfigurationAction rdf:type meta:ReconfigurationAction)
            (?reconfigurationAction ssn:forProperty ?configurableParameter)
            makeTemp(?actionCombination)
            makeTemp(?actionList)
            makeTemp(?configurableParameterList)
            ->  (?actionCombination rdf:type meta:ActionCombination)
                (?actionCombination meta:hasActions ?actionList)
                (?actionList rdf:type rdf:List)
                (?actionList rdf:first ?reconfigurationAction)
                (?actionList rdf:rest rdf:nil)
                (?actionCombination meta:hasConfigurableParameters ?configurableParameterList)
                (?configurableParameterList rdf:type rdf:List)
                (?configurableParameterList rdf:first ?configurableParameter)
                (?configurableParameterList rdf:rest rdf:nil)
]

[rule4c:    (?actionCombination rdf:type meta:ActionCombination)
            (?actionCombination meta:hasActions ?actionList)
            (?actionCombination meta:hasActuators ?actuatorList)
            (?actuationAction rdf:type meta:ActuationAction)
            (?actuationAction meta:hasActuator ?actuator)
            noValue(?actionCombination rdf:comment "duplicate")
            listNotContains(?actuatorList, ?actuator)
            makeTemp(?newActionCombination)
            makeTemp(?newActionList)
            makeTemp(?newActuatorList)
            ->  (?newActionCombination rdf:type meta:ActionCombination)
                (?newActionCombination meta:hasActions ?newActionList)
                (?newActionList rdf:type rdf:List)
                (?newActionList rdf:first ?actuationAction)
                (?newActionList rdf:rest ?actionList)
                (?newActionCombination meta:hasActuators ?newActuatorList)
                (?newActuatorList rdf:type rdf:List)
                (?newActuatorList rdf:first ?actuator)
                (?newActuatorList rdf:rest ?actuatorList)
                (?actionCombination rdf:comment "not final")
]

[rule4d:    (?actionCombination rdf:type meta:ActionCombination)
            (?actionCombination meta:hasActions ?actionList)
            (?actionCombination meta:hasConfigurableParameters ?configurableParameterList)
            (?reconfigurationAction rdf:type meta:ReconfigurationAction)
            (?reconfigurationAction ssn:forProperty ?configurableParameter)
            noValue(?actionCombination rdf:comment "duplicate")
            listNotContains(?configurableParameterList, ?configurableParameter)
            makeTemp(?newActionCombination)
            makeTemp(?newActionList)
            makeTemp(?newConfigurableParameterList)
            ->  (?newActionCombination rdf:type meta:ActionCombination)
                (?newActionCombination meta:hasActions ?newActionList)
                (?newActionList rdf:type rdf:List)
                (?newActionList rdf:first ?reconfigurationAction)
                (?newActionList rdf:rest ?actionList)
                (?newActionCombination meta:hasConfigurableParameters ?newConfigurableParameterList)
                (?newConfigurableParameterList rdf:type rdf:List)
                (?newConfigurableParameterList rdf:first ?configurableParameter)
                (?newConfigurableParameterList rdf:rest ?configurableParameterList)
                (?actionCombination rdf:comment "not final")
]

[rule4e:    (?actionCombination1 rdf:type meta:ActionCombination)
            (?actionCombination1 meta:hasActions ?actionList1)
            (?actionCombination2 rdf:type meta:ActionCombination)
            (?actionCombination2 meta:hasActions ?actionList2)
            notEqual(?actionCombination1, ?actionCombination2)
            noValue(?actionCombination1 rdf:comment "duplicate")
            noValue(?actionCombination2 rdf:comment "duplicate")
            listEqual(?actionList1, ?actionList2)
            ->  (?actionCombination2 rdf:comment "duplicate")
]