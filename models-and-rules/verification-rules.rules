@prefix : <http://www.semanticweb.org/ivans/ontologies/2025/instance-model-1#>.
@prefix meta: <http://www.semanticweb.org/ivans/ontologies/2025/ruleless-digital-twins/>.
@prefix ssn: <http://www.w3.org/ns/ssn/>.
@prefix sosa: <http://www.w3.org/ns/sosa/>.
@include <OWL>.

// Verifies that system optimizations are not conflicting.
[rule1g:    (?thing1 meta:optimizesFor ?propertyChange1)
            (?propertyChange1 ssn:forProperty ?property)
            (?thing2 meta:optimizesFor ?propertyChange2)
            (?propertyChange2 ssn:forProperty ?property)
            (?propertyChange1 meta:affectsPropertyWith meta:ValueIncrease)
            (?propertyChange2 meta:affectsPropertyWith meta:ValueDecrease)
            ->  print()
                print("Conflicting optimizations detected!")
                print(?thing1, "optimizes for", ?property, "with ValueIncrease through", ?propertyChange1)
                print(?thing2, "optimizes for", ?property, "with ValueDecrease through", ?propertyChange2)
                print()
]

// Checks for two different OptimalConditions with conflicting constraints for the same Property. This is only an
// issue in the case of impossible values for specific combinations of operators. In other words, using some
// combinations of operators in conjunction is legitimate if they produce a legitimate range for a value. E.g.,
// OptimalCondition1 having a constraint of >15 and OptimalCondition2 having a constraint of <20. However, such
// combinations are not valid in cases of swapped values, i.e., OptimalCondition1 having a constraint of >20
// and OptimalCondition2 having a constraint of <15, meaning the same Property would have to have a value of
// >20 and <15 at the same time.
//
// To represent disjoint ranges, we offer support for disjunctions. E.g., >20 or <15.

// Checks for OptimalConditions with single-valued range constraints.
[rule1h:    (?individual1 rdf:type meta:OptimalCondition)
            (?individual1 ssn:forProperty ?property)
            (?individual1 rdf:type ?bNode1_1)
            (?bNode1_1 owl:onProperty meta:hasValueConstraint)
            (?bNode1_1 owl:onDataRange ?bNode2_1)
            (?bNode2_1 owl:withRestrictions ?bNode3_1)
            (?bNode3_1 rdf:first ?restriction1)
            noValue(?bNode3_1, rdf:rest, isBNode(?bNode4_1))
            (?individual2 rdf:type meta:OptimalCondition)
            (?individual2 ssn:forProperty ?property)
            (?individual2 rdf:type ?bNode1_2)
            (?bNode1_2 owl:onProperty meta:hasValueConstraint)
            (?bNode1_2 owl:onDataRange ?bNode2_2)
            (?bNode2_2 owl:withRestrictions ?bNode3_2)
            (?bNode3_2 rdf:first ?restriction2)
            noValue(?bNode3_2, rdf:rest, isBNode(?bNode4_2))
            ->  (?restriction1 rdf:comment "verification mark")
                (?restriction2 rdf:comment "verification mark")
]

// Checks for OptimalConditions where one has a single-valued and the other a double-valued range constraint.
[rule1i:    (?individual1 rdf:type meta:OptimalCondition)
            (?individual1 ssn:forProperty ?property)
            (?individual1 rdf:type ?bNode1_1)
            (?bNode1_1 owl:onProperty meta:hasValueConstraint)
            (?bNode1_1 owl:onDataRange ?bNode2_1)
            (?bNode2_1 owl:withRestrictions ?bNode3_1)
            (?bNode3_1 rdf:first ?restriction1)
            (?bNode3_1 rdf:rest ?bNode4_1)
            (?bNode4_1 rdf:first ?restriction2)
            (?individual2 rdf:type meta:OptimalCondition)
            (?individual2 ssn:forProperty ?property)
            (?individual2 rdf:type ?bNode1_2)
            (?bNode1_2 owl:onProperty meta:hasValueConstraint)
            (?bNode1_2 owl:onDataRange ?bNode2_2)
            (?bNode2_2 owl:withRestrictions ?bNode3_2)
            (?bNode3_2 rdf:first ?restriction3)
            noValue(?bNode3_2, rdf:rest, isBNode(?bNode4_2))
            ->  (?restriction1 rdf:comment "verification mark")
                (?restriction2 rdf:comment "verification mark")
                (?restriction3 rdf:comment "verification mark")
]

// Checks for OptimalConditions with double-valued range constraints.
[rule1j:    (?individual1 rdf:type meta:OptimalCondition)
            (?individual1 ssn:forProperty ?property)
            (?individual1 rdf:type ?bNode1_1)
            (?bNode1_1 owl:onProperty meta:hasValueConstraint)
            (?bNode1_1 owl:onDataRange ?bNode2_1)
            (?bNode2_1 owl:withRestrictions ?bNode3_1)
            (?bNode3_1 rdf:first ?restriction1)
            (?bNode3_1 rdf:rest ?bNode4_1)
            (?bNode4_1 rdf:first ?restriction2)
            (?individual2 rdf:type meta:OptimalCondition)
            (?individual2 ssn:forProperty ?property)
            (?individual2 rdf:type ?bNode1_2)
            (?bNode1_2 owl:onProperty meta:hasValueConstraint)
            (?bNode1_2 owl:onDataRange ?bNode2_2)
            (?bNode2_2 owl:withRestrictions ?bNode3_2)
            (?bNode3_2 rdf:first ?restriction3)
            (?bNode3_2 rdf:rest ?bNode4_2)
            (?bNode4_2 rdf:first ?restriction4)
            ->  (?restriction1 rdf:comment "verification mark")
                (?restriction2 rdf:comment "verification mark")
                (?restriction3 rdf:comment "verification mark")
                (?restriction4 rdf:comment "verification mark")
]

// Checks if the marked constraints have disallowed values for '>' and '<' operators.
[rule1k:    (?restriction1 rdf:comment ?property)
            (?restriction1 rdf:comment "verification mark")
            (?restriction1 xsd:minExclusive ?value1)
            (?restriction2 rdf:comment ?property)
            (?restriction2 rdf:comment "verification mark")
            (?restriction2 xsd:maxExclusive ?value2)
            notEqual(?property, "verification mark")
            ge(?value1, ?value2)
            ->  print()
                print("Conflicting conditions detected!")
                print("Conditions for", ?property, "are >", ?value1, "and <", ?value2, "at the same time.")
                print()
]

// Checks if the marked constraints have disallowed values for '>=' and '<' operators.
[rule1l:    (?restriction1 rdf:comment ?property)
            (?restriction1 rdf:comment "verification mark")
            (?restriction1 xsd:minInclusive ?value1)
            (?restriction2 rdf:comment ?property)
            (?restriction2 rdf:comment "verification mark")
            (?restriction2 xsd:maxExclusive ?value2)
            notEqual(?property, "verification mark")
            ge(?value1, ?value2)
            ->  print()
                print("Conflicting conditions detected!")
                print("Conditions for", ?property, "are >=", ?value1, "and <", ?value2, "at the same time.")
                print()
]

// Checks if the marked constraints have disallowed values for '>' and '<=' operators.
[rule1m:    (?restriction1 rdf:comment ?property)
            (?restriction1 rdf:comment "verification mark")
            (?restriction1 xsd:minExclusive ?value1)
            (?restriction2 rdf:comment ?property)
            (?restriction2 rdf:comment "verification mark")
            (?restriction2 xsd:maxInclusive ?value2)
            notEqual(?property, "verification mark")
            ge(?value1, ?value2)
            ->  print()
                print("Conflicting conditions detected!")
                print("Conditions for", ?property, "are >", ?value1, "and <=", ?value2, "at the same time.")
                print()
]

// Checks if the marked constraints have disallowed values for '>=' and '<=' operators.
[rule1n:    (?restriction1 rdf:comment ?property)
            (?restriction1 rdf:comment "verification mark")
            (?restriction1 xsd:minInclusive ?value1)
            (?restriction2 rdf:comment ?property)
            (?restriction2 rdf:comment "verification mark")
            (?restriction2 xsd:maxInclusive ?value2)
            notEqual(?property, "verification mark")
            greaterThan(?value1, ?value2)
            ->  print()
                print("Conflicting conditions detected!")
                print("Conditions for", ?property, "are >=", ?value1, "and <=", ?value2, "at the same time.")
                print()
]