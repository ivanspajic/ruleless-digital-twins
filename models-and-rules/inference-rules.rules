@prefix : <http://www.semanticweb.org/ivans/ontologies/2025/instance-model-1#>.
@prefix meta: <http://www.semanticweb.org/ivans/ontologies/2025/ruleless-digital-twins/>.
@prefix ssn: <http://www.w3.org/ns/ssn/>.
@prefix sosa: <http://www.w3.org/ns/sosa/>.
@include <verification-rules.rules>.
@include <user-rules.rules>.



// Upon locating the marks for OptimalCondition constraints, these rules find the relevant PropertyChanges and use them as a temporary mark
// for subsequent rules.

[rule1a:    (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition rdf:type ?aNode1)
            (?aNode1 owl:onProperty ?objectProperty)
            (?aNode1 owl:onClass ?aNode2)
            ->  (?aNode2 :withObjectProperty ?objectProperty)
]

// TODO: add checks for atomic enabling constraints. these should be evaluated and marked as true or false
// with this info, check the full constraints, and mark the appropriate optimalcondition as either enabled (true) or disabled (false)
// update the current condition-constraint-evaluating rules to check for whether the optimalcondition is enabled or disabled
// for enabled conditions, evaluate the constraints (provided they`re valid and thus remain enabled) and mark them as true or false
// with this info, generate propertychanges directly if the constraints are not a part of a larger disjunctive constraint
// otherwise, generate propertychanges only if the whole disjunctive constraint evaluates to false

[rule1b:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?aNode owl:hasValue ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?aNode owl:onProperty meta:equalTo)
            noValue(?aNode :withCheck "conjunction")
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesGreaterThan ?boundProperty)
                (?evaluationContainer :evaluatesLessThan ?boundProperty)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
]

[rule1c:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?aNode owl:hasValue ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?aNode owl:onProperty meta:lessThan)
            noValue(?aNode :withCheck "conjunction")
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesGreaterThanOrEqualTo ?boundProperty)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
]

[rule1d:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?aNode owl:hasValue ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?aNode owl:onProperty meta:lessThanOrEqualTo)
            noValue(?aNode :withCheck "conjunction")
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesGreaterThan ?boundProperty)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
]

[rule1e:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?aNode owl:hasValue ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?aNode owl:onProperty meta:greaterThan)
            noValue(?aNode :withCheck "conjunction")
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesLessThanOrEqualTo ?boundProperty)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
]

[rule1f:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?aNode owl:hasValue ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?aNode owl:onProperty meta:greaterThanOrEqualTo)
            noValue(?aNode :withCheck "conjunction")
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesLessThan ?boundProperty)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
]

[rule1g:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode1 :withOptimalConditionProperty ?optimalConditionProperty1)
            (?optimalConditionProperty1 meta:hasValue ?optimalConditionProperty1Value)
            (?aNode1 :withCheck "conjunction")
            (?aNode1 :withIdentifier ?identifier1)
            (?aNode1 owl:hasValue ?boundProperty1)
            (?boundProperty1 meta:hasValue ?boundProperty1Value)
            (?aNode1 owl:onProperty meta:equalTo)
            (?aNode2 :withOptimalConditionProperty ?optimalConditionProperty2)
            (?optimalConditionProperty2 meta:hasValue ?optimalConditionProperty2Value)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withIdentifier ?identifier2)
            (?aNode2 owl:hasValue ?boundProperty2)
            (?boundProperty2 meta:hasValue ?boundProperty2Value)
            (?aNode2 owl:onProperty meta:equalTo)
            equal(?identifier1, ?identifier2)
            equal(?optimalConditionProperty1, ?optimalConditionProperty2)
            notEqual(?boundProperty1, ?boundProperty2)
            equal(?boundProperty1Value, ?boundProperty2Value)
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesLessThan ?boundProperty1)
                (?evaluationContainer :evaluatesGreaterThan ?boundProperty1)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty1)
]

[rule1h:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode1 :withOptimalConditionProperty ?optimalConditionProperty1)
            (?optimalConditionProperty1 meta:hasValue ?optimalConditionProperty1Value)
            (?aNode1 :withCheck "conjunction")
            (?aNode1 :withIdentifier ?identifier1)
            (?aNode1 owl:hasValue ?boundProperty1)
            (?boundProperty1 meta:hasValue ?boundProperty1Value)
            (?aNode1 owl:onProperty meta:equalTo)
            (?aNode2 :withOptimalConditionProperty ?optimalConditionProperty2)
            (?optimalConditionProperty2 meta:hasValue ?optimalConditionProperty2Value)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withIdentifier ?identifier2)
            (?aNode2 owl:hasValue ?boundProperty2)
            (?boundProperty2 meta:hasValue ?boundProperty2Value)
            (?aNode2 owl:onProperty meta:lessThanOrEqualTo)
            equal(?identifier1, ?identifier2)
            equal(?optimalConditionProperty1, ?optimalConditionProperty2)
            notEqual(?boundProperty1, ?boundProperty2)
            equal(?boundProperty1Value, ?boundProperty2Value)
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesLessThan ?boundProperty1)
                (?evaluationContainer :evaluatesGreaterThan ?boundProperty1)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty1)
]

[rule1i:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode1 :withOptimalConditionProperty ?optimalConditionProperty1)
            (?optimalConditionProperty1 meta:hasValue ?optimalConditionProperty1Value)
            (?aNode1 :withCheck "conjunction")
            (?aNode1 :withIdentifier ?identifier1)
            (?aNode1 owl:hasValue ?boundProperty1)
            (?boundProperty1 meta:hasValue ?boundProperty1Value)
            (?aNode1 owl:onProperty meta:equalTo)
            (?aNode2 :withOptimalConditionProperty ?optimalConditionProperty2)
            (?optimalConditionProperty2 meta:hasValue ?optimalConditionProperty2Value)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withIdentifier ?identifier2)
            (?aNode2 owl:hasValue ?boundProperty2)
            (?boundProperty2 meta:hasValue ?boundProperty2Value)
            (?aNode2 owl:onProperty meta:greaterThanOrEqualTo)
            equal(?identifier1, ?identifier2)
            equal(?optimalConditionProperty1, ?optimalConditionProperty2)
            notEqual(?boundProperty1, ?boundProperty2)
            equal(?boundProperty1Value, ?boundProperty2Value)
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesLessThan ?boundProperty1)
                (?evaluationContainer :evaluatesGreaterThan ?boundProperty1)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty1)
]

[rule1j:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode1 :withOptimalConditionProperty ?optimalConditionProperty1)
            (?optimalConditionProperty1 meta:hasValue ?optimalConditionProperty1Value)
            (?aNode1 :withCheck "conjunction")
            (?aNode1 :withIdentifier ?identifier1)
            (?aNode1 owl:hasValue ?boundProperty1)
            (?boundProperty1 meta:hasValue ?boundProperty1Value)
            (?aNode1 owl:onProperty meta:greaterThan)
            (?aNode2 :withOptimalConditionProperty ?optimalConditionProperty2)
            (?optimalConditionProperty2 meta:hasValue ?optimalConditionProperty2Value)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withIdentifier ?identifier2)
            (?aNode2 owl:hasValue ?boundProperty2)
            (?boundProperty2 meta:hasValue ?boundProperty2Value)
            (?aNode2 owl:onProperty meta:lessThan)
            equal(?identifier1, ?identifier2)
            equal(?optimalConditionProperty1, ?optimalConditionProperty2)
            notEqual(?boundProperty1, ?boundProperty2)
            lessThan(?boundProperty1Value, ?boundProperty2Value)
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesLessThanOrEqualTo ?boundProperty1)
                (?evaluationContainer :evaluatesGreaterThanOrEqualTo ?boundProperty2)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty1)
]

[rule1k:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode1 :withOptimalConditionProperty ?optimalConditionProperty1)
            (?optimalConditionProperty1 meta:hasValue ?optimalConditionProperty1Value)
            (?aNode1 :withCheck "conjunction")
            (?aNode1 :withIdentifier ?identifier1)
            (?aNode1 owl:hasValue ?boundProperty1)
            (?boundProperty1 meta:hasValue ?boundProperty1Value)
            (?aNode1 owl:onProperty meta:greaterThan)
            (?aNode2 :withOptimalConditionProperty ?optimalConditionProperty2)
            (?optimalConditionProperty2 meta:hasValue ?optimalConditionProperty2Value)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withIdentifier ?identifier2)
            (?aNode2 owl:hasValue ?boundProperty2)
            (?boundProperty2 meta:hasValue ?boundProperty2Value)
            (?aNode2 owl:onProperty meta:lessThanOrEqualTo)
            equal(?identifier1, ?identifier2)
            equal(?optimalConditionProperty1, ?optimalConditionProperty2)
            notEqual(?boundProperty1, ?boundProperty2)
            lessThan(?boundProperty1Value, ?boundProperty2Value)
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesLessThanOrEqualTo ?boundProperty1)
                (?evaluationContainer :evaluatesGreaterThan ?boundProperty2)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty1)
]

[rule1l:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode1 :withOptimalConditionProperty ?optimalConditionProperty1)
            (?optimalConditionProperty1 meta:hasValue ?optimalConditionProperty1Value)
            (?aNode1 :withCheck "conjunction")
            (?aNode1 :withIdentifier ?identifier1)
            (?aNode1 owl:hasValue ?boundProperty1)
            (?boundProperty1 meta:hasValue ?boundProperty1Value)
            (?aNode1 owl:onProperty meta:greaterThanOrEqualTo)
            (?aNode2 :withOptimalConditionProperty ?optimalConditionProperty2)
            (?optimalConditionProperty2 meta:hasValue ?optimalConditionProperty2Value)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withIdentifier ?identifier2)
            (?aNode2 owl:hasValue ?boundProperty2)
            (?boundProperty2 meta:hasValue ?boundProperty2Value)
            (?aNode2 owl:onProperty meta:lessThan)
            equal(?identifier1, ?identifier2)
            equal(?optimalConditionProperty1, ?optimalConditionProperty2)
            notEqual(?boundProperty1, ?boundProperty2)
            lessThan(?boundProperty1Value, ?boundProperty2Value)
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesLessThan ?boundProperty1)
                (?evaluationContainer :evaluatesGreaterThanOrEqualTo ?boundProperty2)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty1)
]

[rule1m:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode1 :withOptimalConditionProperty ?optimalConditionProperty1)
            (?optimalConditionProperty1 meta:hasValue ?optimalConditionProperty1Value)
            (?aNode1 :withCheck "conjunction")
            (?aNode1 :withIdentifier ?identifier1)
            (?aNode1 owl:hasValue ?boundProperty1)
            (?boundProperty1 meta:hasValue ?boundProperty1Value)
            (?aNode1 owl:onProperty meta:greaterThanOrEqualTo)
            (?aNode2 :withOptimalConditionProperty ?optimalConditionProperty2)
            (?optimalConditionProperty2 meta:hasValue ?optimalConditionProperty2Value)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withIdentifier ?identifier2)
            (?aNode2 owl:hasValue ?boundProperty2)
            (?boundProperty2 meta:hasValue ?boundProperty2Value)
            (?aNode2 owl:onProperty meta:lessThanOrEqualTo)
            equal(?identifier1, ?identifier2)
            equal(?optimalConditionProperty1, ?optimalConditionProperty2)
            notEqual(?boundProperty1, ?boundProperty2)
            le(?boundProperty1Value, ?boundProperty2Value)
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :evaluatesLessThan ?boundProperty1)
                (?evaluationContainer :evaluatesGreaterThan ?boundProperty2)
                (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty1)
]



// These rules locate the temporary containers produced by the first rules, evaluate them, and mark the required PropertyChanges.

[rule2a:    (?bNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?bNode :evaluatesGreaterThan ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueDecrease)
            greaterThan(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (_: :withPropertyChange ?propertyChange)
]

[rule2b:    (?bNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?bNode :evaluatesGreaterThanOrEqualTo ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueDecrease)
            ge(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (_: :withPropertyChange ?propertyChange)
]

[rule2c:    (?bNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?bNode :evaluatesLessThan ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueIncrease)
            lessThan(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (_: :withPropertyChange ?propertyChange)
]

[rule2d:    (?bNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?bNode :evaluatesLessThanOrEqualTo ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueIncrease)
            le(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (_: :withPropertyChange ?propertyChange)
]



// The following rules locate PropertyChange marks and generate appropriate Actions, either with Actuators or ConfigurableParameters. URI
// concatinations are used for generating unique names for unique combinations of elements in an Action. This ensures that no duplicate Actions
// are generated in cases of, e.g., multiple actuators causing multiple different PropertyChanges.

[rule3a:   (?thing :withPropertyChange ?propertyChange)
           (?actuator meta:enacts ?propertyChange)
           (?actuator rdf:type sosa:Actuator)
           (?actuator meta:hasActuatorState ?actuatorState)
           uriConcat(?actuator, "_", ?actuatorState, ?actionName)
           ->  (?actionName rdf:type meta:ActuationAction)
               (?actionName meta:hasActuator ?actuator)
               (?actionName meta:hasActuatorState ?actuatorState)
               print("Generated ActuationAction", ?actionName)
]

[rule3b:   (?thing :withPropertyChange ?propertyChange)
           (?configurableParameter meta:enacts ?propertyChange)
           (?configurableParameter rdf:type meta:ConfigurableParameter)
           (?configurableParameter meta:hasPossibleValue ?configurableParameterValue)
           uriConcat(?configurableParameter, "_", ?configurableParameterValue, ?actionName)
           ->  (?actionName rdf:type meta:ReconfigurationAction)
               (?actionName ssn:forProperty ?configurableParameter)
               (?actionName meta:hasValue ?configurableParameterValue)
               print("Generated ReconfigurationAction", ?actionName)
]

// The following rules generate Actions provided the switch for generating restrictive combinations (only based on unsatisfied OptimalConditions)
// is disabled.

[rule3c:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "false"^^xsd:boolean)
            (?actuator rdf:type sosa:Actuator)
            (?actuator meta:hasActuatorState ?actuatorState)
            uriConcat(?actuator, "_", ?actuatorState, ?actionName)
            ->  (?actionName rdf:type meta:ActuationAction)
                (?actionName meta:hasActuator ?actuator)
                (?actionName meta:hasActuatorState ?actuatorState)
                print("Generated ActuationAction", ?actionName)
]

[rule3d:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "false"^^xsd:boolean)
            (?configurableParameter rdf:type meta:ConfigurableParameter)
            (?configurableParameter meta:hasPossibleValue ?configurableParameterValue)
            uriConcat(?configurableParameter, "_", ?configurableParameterValue, ?actionName)
            ->  (?actionName rdf:type meta:ReconfigurationAction)
                (?actionName ssn:forProperty ?configurableParameter)
                (?actionName meta:hasValue ?configurableParameterValue)
                print("Generated ReconfigurationAction", ?actionName)
]



// The following rules infer possible combinations of Actions to take as part of the DT`s final decision. They effectively produce a
// cartesian product of a variable number of sets (Actions grouped by Actuators or ConfigurableParameters) with a variable number of
// elements (possible Actuator states or ConfigurableParameter values).
//
// The rules work by initially creating an ActionCombination for each Action found in the model (rules 4a and 4b). Every ActionCombination
// contains an rdf:List of Actions, which it then expands as it encounters new ones (rules 4c and 4d). To be added to the list, these Actions
// must not already be contained in it and their Actuators/ConfigurableParameters must not be the same as those of other Actions already
// in it. Because this method generates permutations (lists of the same Actions in different orders), additional rules (rules 4e and 4f)
// are necessary to eliminate duplicates and reduce the combinatorial explosion.
//
// In the end, all ActionCombinations that are NOT marked with "duplicate" (same combination already exists) or "not final" (the combination
// contains fewer Actions than it should) are final.

[rule4a:    (?actuationAction rdf:type meta:ActuationAction)
            (?actuationAction meta:hasActuator ?actuator)
            makeTemp(?actionCombination)
            makeTemp(?actionList)
            makeTemp(?actuatorList)
            ->  (?actionCombination rdf:type meta:ActionCombination)
                (?actionCombination meta:hasActions ?actionList)
                (?actionList rdf:type rdf:List)
                (?actionList rdf:first ?actuationAction)
                (?actionList rdf:rest rdf:nil)
                (?actionCombination meta:hasActuators ?actuatorList)
                (?actuatorList rdf:type rdf:List)
                (?actuatorList rdf:first ?actuator)
                (?actuatorList rdf:rest rdf:nil)
]

[rule4b:    (?reconfigurationAction rdf:type meta:ReconfigurationAction)
            (?reconfigurationAction ssn:forProperty ?configurableParameter)
            makeTemp(?actionCombination)
            makeTemp(?actionList)
            makeTemp(?configurableParameterList)
            ->  (?actionCombination rdf:type meta:ActionCombination)
                (?actionCombination meta:hasActions ?actionList)
                (?actionList rdf:type rdf:List)
                (?actionList rdf:first ?reconfigurationAction)
                (?actionList rdf:rest rdf:nil)
                (?actionCombination meta:hasConfigurableParameters ?configurableParameterList)
                (?configurableParameterList rdf:type rdf:List)
                (?configurableParameterList rdf:first ?configurableParameter)
                (?configurableParameterList rdf:rest rdf:nil)
]

[rule4c:    (?actionCombination rdf:type meta:ActionCombination)
            (?actionCombination meta:hasActions ?actionList)
            (?actionCombination meta:hasActuators ?actuatorList)
            (?actuationAction rdf:type meta:ActuationAction)
            (?actuationAction meta:hasActuator ?actuator)
            noValue(?actionCombination rdf:comment "duplicate")
            listNotContains(?actuatorList, ?actuator)
            makeTemp(?newActionCombination)
            makeTemp(?newActionList)
            makeTemp(?newActuatorList)
            ->  (?newActionCombination rdf:type meta:ActionCombination)
                (?newActionCombination meta:hasActions ?newActionList)
                (?newActionList rdf:type rdf:List)
                (?newActionList rdf:first ?actuationAction)
                (?newActionList rdf:rest ?actionList)
                (?newActionCombination meta:hasActuators ?newActuatorList)
                (?newActuatorList rdf:type rdf:List)
                (?newActuatorList rdf:first ?actuator)
                (?newActuatorList rdf:rest ?actuatorList)
                (?actionCombination rdf:comment "not final")
]

[rule4d:    (?actionCombination rdf:type meta:ActionCombination)
            (?actionCombination meta:hasActions ?actionList)
            (?actionCombination meta:hasConfigurableParameters ?configurableParameterList)
            (?reconfigurationAction rdf:type meta:ReconfigurationAction)
            (?reconfigurationAction ssn:forProperty ?configurableParameter)
            noValue(?actionCombination rdf:comment "duplicate")
            listNotContains(?configurableParameterList, ?configurableParameter)
            makeTemp(?newActionCombination)
            makeTemp(?newActionList)
            makeTemp(?newConfigurableParameterList)
            ->  (?newActionCombination rdf:type meta:ActionCombination)
                (?newActionCombination meta:hasActions ?newActionList)
                (?newActionList rdf:type rdf:List)
                (?newActionList rdf:first ?reconfigurationAction)
                (?newActionList rdf:rest ?actionList)
                (?newActionCombination meta:hasConfigurableParameters ?newConfigurableParameterList)
                (?newConfigurableParameterList rdf:type rdf:List)
                (?newConfigurableParameterList rdf:first ?configurableParameter)
                (?newConfigurableParameterList rdf:rest ?configurableParameterList)
                (?actionCombination rdf:comment "not final")
]

[rule4e:    (?actionCombination1 rdf:type meta:ActionCombination)
            (?actionCombination1 meta:hasActions ?actionList1)
            (?actionCombination2 rdf:type meta:ActionCombination)
            (?actionCombination2 meta:hasActions ?actionList2)
            notEqual(?actionCombination1, ?actionCombination2)
            noValue(?actionCombination1 rdf:comment "duplicate")
            noValue(?actionCombination2 rdf:comment "duplicate")
            listEqual(?actionList1, ?actionList2)
            ->  (?actionCombination2 rdf:comment "duplicate")
]