@prefix : <http://www.semanticweb.org/ivans/ontologies/2025/instance-model-1#>.
@prefix meta: <http://www.semanticweb.org/ivans/ontologies/2025/ruleless-digital-twins/>.
@prefix ssn: <http://www.w3.org/ns/ssn/>.
@prefix sosa: <http://www.w3.org/ns/sosa/>.



// These rules are used as a verification mechanism against malformed or impossible OptimalConditions. In cases of errors, these rules will
// explicitly print error messages such that the coordinator catches them and throws exceptions.

// Verifies that system optimizations are not conflicting.
[ruleVer1a: (?platform rdf:type sosa:Platform)
            (?platform meta:optimizesFor ?propertyChange1)
            (?propertyChange1 ssn:forProperty ?property)
            (?platform meta:optimizesFor ?propertyChange2)
            (?propertyChange2 ssn:forProperty ?property)
            (?propertyChange1 meta:affectsPropertyWith meta:ValueIncrease)
            (?propertyChange2 meta:affectsPropertyWith meta:ValueDecrease)
            ->  print("Error!")
                print(?platform, "optimizes for", ?property, "with ValueIncrease through", ?propertyChange1)
                print(?platform, "optimizes for", ?property, "with ValueDecrease through", ?propertyChange2)
]

// Marks single-constraint OptimalConditions, such as >15, for further checks.
[ruleVer1b: (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition rdf:type ?aNode1)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 rdf:type owl:Restriction)
            (?aNode1 owl:onProperty ?constraintType)
            (?aNode1 owl:onClass ?aNode2)
            (?aNode2 rdf:type owl:Restriction)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty ?operator)
            ->  (?aNode2 :withOptimalCondition ?optimalCondition)
                (?aNode2 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode2 :withOperatorCheck ?operator)
                (?aNode2 :withPropertyCheck ?optimalConditionProperty)
                (?aNode2 :withPropertyCheck ?boundProperty)
                (?aNode2 :withConstraintType ?constraintType)
]

// Marks conjunctive OptimalConditions, such as >15 and <22, for further checks.
[ruleVer1c: (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition rdf:type ?aNode1)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 rdf:type owl:Restriction)
            (?aNode1 owl:onProperty ?constraintType)
            (?aNode1 owl:onClass ?aNode2)
            (?aNode2 owl:intersectionOf ?aList1)
            (?aList1 rdf:first ?aNode3)
            (?aNode3 rdf:type owl:Restriction)
            (?aNode3 owl:hasValue ?boundProperty1)
            (?aNode3 owl:onProperty ?operator1)
            (?aList1 rdf:rest ?aList2)
            (?aList2 rdf:first ?aNode4)
            (?aNode4 rdf:type owl:Restriction)
            (?aNode4 owl:hasValue ?boundProperty2)
            (?aNode4 owl:onProperty ?operator2)
            makeTemp(?identifier)
            ->  (?aNode3 :withOptimalCondition ?optimalCondition)
                (?aNode3 :withIdentifier ?identifier)
                (?aNode3 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode3 :withCheck "conjunction")
                (?aNode3 :withOperatorCheck ?operator1)
                (?aNode3 :withPropertyCheck ?optimalConditionProperty)
                (?aNode3 :withPropertyCheck ?boundProperty1)
                (?aNode3 :withConstraintType ?constraintType)
                (?aNode4 :withOptimalCondition ?optimalCondition)
                (?aNode4 :withIdentifier ?identifier)
                (?aNode4 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode4 :withCheck "conjunction")
                (?aNode4 :withOperatorCheck ?operator2)
                (?aNode4 :withPropertyCheck ?boundProperty2)
                (?aNode4 :withConstraintType ?constraintType)
]

// Marks single-single-constraint disjunctive OptimalConditions, such as <15 or >22, for further checks.
[ruleVer1d: (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition rdf:type ?aNode1)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 rdf:type owl:Restriction)
            (?aNode1 owl:onProperty ?constraintType)
            (?aNode1 owl:onClass ?aNode2)
            (?aNode2 owl:unionOf ?aList1)
            (?aList1 rdf:first ?aNode3)
            (?aNode3 rdf:type owl:Restriction)
            (?aNode3 owl:hasValue ?boundProperty1)
            (?aNode3 owl:onProperty ?operator1)
            (?aList1 rdf:rest ?aList2)
            (?aList2 rdf:first ?aNode4)
            (?aNode4 rdf:type owl:Restriction)
            (?aNode4 owl:hasValue ?boundProperty2)
            (?aNode4 owl:onProperty ?operator2)
            ->  (?aNode3 :withOptimalCondition ?optimalCondition)
                (?aNode3 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode3 :withCheck "disjunction")
                (?aNode3 :withOperatorCheck ?operator1)
                (?aNode3 :withPropertyCheck ?optimalConditionProperty)
                (?aNode3 :withPropertyCheck ?boundProperty1)
                (?aNode3 :withConstraintType ?constraintType)
                (?aNode4 :withOptimalCondition ?optimalCondition)
                (?aNode4 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode4 :withCheck "disjunction")
                (?aNode4 :withOperatorCheck ?operator2)
                (?aNode4 :withPropertyCheck ?boundProperty2)
                (?aNode4 :withConstraintType ?constraintType)
]

// Marks double-single-constraint disjunctive OptimalConditions, such as (>15 and <22) or >34, for further checks.
[ruleVer1e: (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition rdf:type ?aNode1)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 rdf:type owl:Restriction)
            (?aNode1 owl:onProperty ?constraintType)
            (?aNode1 owl:onClass ?aNode2)
            (?aNode2 owl:unionOf ?aList1)
            (?aList1 rdf:first ?aNode3)
            (?aNode3 owl:intersectionOf ?aList2)
            (?aList2 rdf:first ?aNode4)
            (?aNode4 rdf:type owl:Restriction)
            (?aNode4 owl:hasValue ?boundProperty1)
            (?aNode4 owl:onProperty ?operator1)
            (?aList2 rdf:rest ?aList3)
            (?aList3 rdf:first ?aNode5)
            (?aNode5 rdf:type owl:Restriction)
            (?aNode5 owl:hasValue ?boundProperty2)
            (?aNode5 owl:onProperty ?operator2)
            (?aList1 rdf:rest ?aList4)
            (?aList4 rdf:first ?aNode6)
            (?aNode6 rdf:type owl:Restriction)
            (?aNode6 owl:hasValue ?boundProperty3)
            (?aNode6 owl:onProperty ?operator3)
            makeTemp(?identifier)
            ->  (?aNode4 :withOptimalCondition ?optimalCondition)
                (?aNode4 :withIdentifier ?identifier)
                (?aNode4 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode4 :withCheck "conjunction")
                (?aNode4 :withCheck "disjunction")
                (?aNode4 :withOperatorCheck ?operator1)
                (?aNode4 :withPropertyCheck ?optimalConditionProperty)
                (?aNode4 :withPropertyCheck ?boundProperty1)
                (?aNode4 :withConstraintType ?constraintType)
                (?aNode5 :withOptimalCondition ?optimalCondition)
                (?aNode5 :withIdentifier ?identifier)
                (?aNode5 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode5 :withCheck "conjunction")
                (?aNode5 :withCheck "disjunction")
                (?aNode5 :withOperatorCheck ?operator2)
                (?aNode5 :withPropertyCheck ?boundProperty2)
                (?aNode5 :withConstraintType ?constraintType)
                (?aNode6 :withOptimalCondition ?optimalCondition)
                (?aNode6 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode6 :withOperatorCheck ?operator3)
                (?aNode6 :withPropertyCheck ?boundProperty3)
                (?aNode6 :withCheck "disjunction")
                (?aNode6 :withConstraintType ?constraintType)
]

// Marks double-double-constraint disjunctive OptimalConditions such as (>15 and <22) or (>34 and <45), for further checks.
[ruleVer1f: (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition rdf:type ?aNode1)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 rdf:type owl:Restriction)
            (?aNode1 owl:onProperty ?constraintType)
            (?aNode1 owl:onClass ?aNode2)
            (?aNode2 owl:unionOf ?aList1)
            (?aList1 rdf:first ?aNode3)
            (?aNode3 owl:intersectionOf ?aList2)
            (?aList2 rdf:first ?aNode4)
            (?aNode4 rdf:type owl:Restriction)
            (?aNode4 owl:hasValue ?boundProperty1)
            (?aNode4 owl:onProperty ?operator1)
            (?aList2 rdf:rest ?aList3)
            (?aList3 rdf:first ?aNode5)
            (?aNode5 rdf:type owl:Restriction)
            (?aNode5 owl:hasValue ?boundProperty2)
            (?aNode5 owl:onProperty ?operator2)
            (?aList1 rdf:rest ?aList4)
            (?aList4 rdf:first ?aNode6)
            (?aNode6 owl:intersectionOf ?aList5)
            (?aList5 rdf:first ?aNode7)
            (?aNode7 rdf:type owl:Restriction)
            (?aNode7 owl:hasValue ?boundProperty3)
            (?aNode7 owl:onProperty ?operator3)
            (?aList5 rdf:rest ?aList6)
            (?aList6 rdf:first ?aNode8)
            (?aNode8 rdf:type owl:Restriction)
            (?aNode8 owl:hasValue ?boundProperty4)
            (?aNode8 owl:onProperty ?operator4)
            makeTemp(?identifier1)
            makeTemp(?identifier2)
            ->  (?aNode4 :withOptimalCondition ?optimalCondition)
                (?aNode4 :withIdentifier ?identifier1)
                (?aNode4 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode4 :withCheck "conjunction")
                (?aNode4 :withCheck "disjunction")
                (?aNode4 :withOperatorCheck ?operator1)
                (?aNode4 :withPropertyCheck ?optimalConditionProperty)
                (?aNode4 :withPropertyCheck ?boundProperty1)
                (?aNode4 :withConstraintType ?constraintType)
                (?aNode5 :withOptimalCondition ?optimalCondition)
                (?aNode5 :withIdentifier ?identifier1)
                (?aNode5 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode5 :withCheck "conjunction")
                (?aNode5 :withCheck "disjunction")
                (?aNode5 :withOperatorCheck ?operator2)
                (?aNode5 :withPropertyCheck ?boundProperty2)
                (?aNode5 :withConstraintType ?constraintType)
                (?aNode7 :withOptimalCondition ?optimalCondition)
                (?aNode7 :withIdentifier ?identifier2)
                (?aNode7 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode7 :withCheck "conjunction")
                (?aNode7 :withCheck "disjunction")
                (?aNode7 :withOperatorCheck ?operator3)
                (?aNode7 :withPropertyCheck ?boundProperty3)
                (?aNode7 :withConstraintType ?constraintType)
                (?aNode8 :withOptimalCondition ?optimalCondition)
                (?aNode8 :withIdentifier ?identifier2)
                (?aNode8 :withOptimalConditionProperty ?optimalConditionProperty)
                (?aNode8 :withCheck "conjunction")
                (?aNode8 :withCheck "disjunction")
                (?aNode8 :withOperatorCheck ?operator4)
                (?aNode8 :withPropertyCheck ?boundProperty4)
                (?aNode8 :withConstraintType ?constraintType)
]



// Prints errors if constraints use disallowed object properties as operators.
[ruleVer2a: (?aNode :withOperatorCheck ?operator)
            (?optimalCondition rdf:type ?aNode)
            notEqual(?operator, meta:equalTo)
            notEqual(?operator, meta:greaterThan)
            notEqual(?operator, meta:greaterThanOrEqualTo)
            notEqual(?operator, meta:lessThan)
            notEqual(?operator, meta:lessThanOrEqualTo)
            ->  print("Error!")
                print("Disallowed operator", ?operator, "used in OptimalCondition", ?optimalCondition)
]

// Prints errors if OptimalConditions use anything else in place of Properties.
[ruleVer2b: (?aNode :withPropertyCheck ?property)
            (?optimalCondition rdf:type ?aNode)
            noValue(?property rdf:type ssn:Property)
            noValue(?property rdf:type sosa:ObservableProperty)
            noValue(?property rdf:type meta:ConfigurableParameter)
            ->  print("Error!")
                print("Disallowed Thing", ?property, "used in place of a Property in OptimalCondition", ?optimalCondition)
]

// Prints errors if Properties in OptimalConditions have unsupported value types.
[ruleVer2c: (?aNode :withPropertyCheck ?property)
            (?optimalCondition rdf:type ?aNode)
            (?property meta:hasValue ?value)
            notDType(?value, xsd:double)
            notDType(?value, xsd:int)
            ->  print("Error!")
                print("Unsupported Property value type", ?value, "used in OptimalCondition", ?optimalCondition)
]

// These rules leave marks for subsequent rules to check that the right kinds of PropertyChanges exist for their OptimalCondition constraints.

[ruleVer2d: (?aNode :withOperatorCheck meta:equalTo)
            ->  (?aNode :withPropertyChangeCheck meta:ValueIncrease)
                (?aNode :withPropertyChangeCheck meta:ValueDecrease)
]

[ruleVer2e: (?aNode :withOperatorCheck meta:greaterThan)
            ->  (?aNode :withPropertyChangeCheck meta:ValueIncrease)
]

[ruleVer2f: (?aNode :withOperatorCheck meta:greaterThanOrEqualTo)
            ->  (?aNode :withPropertyChangeCheck meta:ValueIncrease)
]

[ruleVer2g: (?aNode :withOperatorCheck meta:lessThan)
            ->  (?aNode :withPropertyChangeCheck meta:ValueDecrease)
]

[ruleVer2h: (?aNode :withOperatorCheck meta:lessThanOrEqualTo)
            ->  (?aNode :withPropertyChangeCheck meta:ValueDecrease)
]



// The following rules print errors in cases of OptimalConditions that are always impossible.

// = and < the same property is impossible.
[ruleVer2i: (?aNode1 :withCheck "conjunction")
            (?aNode2 :withCheck "conjunction")
            (?aNode1 :withOptimalCondition ?optimalCondition)
            (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 :withIdentifier ?identifier)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:equalTo)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 :withIdentifier ?identifier)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:lessThan)
            isBNode(?identifier)
            ->  print("Error!")
                print("Constraint in OptimalCondition", ?optimalCondition, "requires that", ?optimalConditionProperty)
                print("be both equal to and less than", ?boundProperty)
]

// = and > the same property is impossible.
[ruleVer2j: (?aNode1 :withCheck "conjunction")
            (?aNode2 :withCheck "conjunction")
            (?aNode1 :withOptimalCondition ?optimalCondition)
            (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 :withIdentifier ?identifier)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:equalTo)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 :withIdentifier ?identifier)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:greaterThan)
            isBNode(?identifier)
            ->  print("Error!")
                print("Constraint in OptimalCondition", ?optimalCondition, "requires that", ?optimalConditionProperty)
                print("be both equal to and greater than", ?boundProperty)
]

// < and > the same property is impossible.
[ruleVer2k: (?aNode1 :withCheck "conjunction")
            (?aNode2 :withCheck "conjunction")
            (?aNode1 :withOptimalCondition ?optimalCondition)
            (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 :withIdentifier ?identifier)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:lessThan)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 :withIdentifier ?identifier)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:greaterThan)
            isBNode(?identifier)
            ->  print("Error!")
                print("Constraint in OptimalCondition", ?optimalCondition, "requires that", ?optimalConditionProperty)
                print("be both less than and greater than" ?boundProperty)
]

// < and >= the same property is impossible.
[ruleVer2l: (?aNode1 :withCheck "conjunction")
            (?aNode2 :withCheck "conjunction")
            (?aNode1 :withOptimalCondition ?optimalCondition)
            (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 :withIdentifier ?identifier)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:lessThan)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 :withIdentifier ?identifier)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:greaterThanOrEqualTo)
            isBNode(?identifier)
            ->  print("Error!")
                print("Constraint in OptimalCondition", ?optimalCondition, "requires that", ?optimalConditionProperty)
                print("be both less than and greater than or equal to", ?boundProperty)
]

// > and <= the same property is impossible.
[ruleVer2m: (?aNode1 :withCheck "conjunction")
            (?aNode2 :withCheck "conjunction")
            (?aNode1 :withOptimalCondition ?optimalCondition)
            (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 :withIdentifier ?identifier)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:greaterThan)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 :withIdentifier ?identifier)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:lessThanOrEqualTo)
            isBNode(?identifier)
            ->  print("Error!")
                print("Constraint in OptimalCondition", ?optimalCondition, "requires that", ?optimalConditionProperty)
                print("be both greater than and less than or equal to", ?boundProperty)
]



// These rules print errors in cases of OptimalConditions that are always true (tautologies).

// OptimalCondition Properties should not also be constraint bounds since that will, depending on the operator, always
// either be true (a tautology) or impossible (e.g., roomTemperature < roomTemperature).
[ruleVer2n: (?aNode :withOptimalCondition ?optimalCondition)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode owl:hasValue ?optimalConditionProperty)
            ->  print("Error!")
                print("OptimalCondition", ?optimalCondition, "uses", ?optimalConditionProperty)
                print("as both the OptimalCondition Property and constraint bound.")
]

// > or <= the same property is always true.
[ruleVer2o: (?aNode1 :withCheck "disjunction")
            (?aNode2 :withCheck "disjunction")
            (?aNode1 :withOptimalCondition ?optimalCondition)
            (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:greaterThan)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:lessThanOrEqualTo)
            ->  print("Error!")
                print(?optimalConditionProperty, "in OptimalCondition", ?optimalCondition)
                print("will always be greater than or less than or equal to", ?boundProperty)
]

// < or >= the same property is always true.
[ruleVer2p: (?aNode1 :withCheck "disjunction")
            (?aNode2 :withCheck "disjunction")
            (?aNode1 :withOptimalCondition ?optimalCondition)
            (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:lessThan)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:greaterThanOrEqualTo)
            ->  print("Error!")
                print(?optimalConditionProperty, "in OptimalCondition", ?optimalCondition)
                print("will always be less than or greater than or equal to", ?boundProperty)
]

// >= or <= the same property is always true.
[ruleVer2q: (?aNode1 :withCheck "disjunction")
            (?aNode2 :withCheck "disjunction")
            (?aNode1 :withOptimalCondition ?optimalCondition)
            (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:lessThanOrEqualTo)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:greaterThanOrEqualTo)
            ->  print("Error!")
                print(?optimalConditionProperty, "in OptimalCondition", ?optimalCondition)
                print("will always be less than or equal to or greater than or equal to", ?boundProperty)
]



// These rules print errors in cases of multiple OptimalConditions with conflicting constraints, making them impossible
// to be satisfied at the same time.

// If OptimalCondition1 states some Property must be less than a Property bound, and OptimalCondition2 states that Property must
// be greater than that same Property bound, then these are conflicting OptimalConditions.
[ruleVer2r: (?aNode1 :withOptimalCondition ?optimalCondition1)
            (?optimalCondition1 rdf:type meta:OptimalCondition)
            (?optimalCondition1 ssn:forProperty ?optimalConditionProperty)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:lessThan)
            (?aNode2 :withOptimalCondition ?optimalCondition2)
            (?optimalCondition2 rdf:type meta:OptimalCondition)
            (?optimalCondition2 ssn:forProperty ?optimalConditionProperty)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:greaterThan)
            notEqual(?optimalCondition1, ?optimalCondition2)
            ->  print("Error!")
                print("OptimalConditions", ?optimalCondition1, "and", ?optimalCondition2, "define conflicting constraints.")
                print(?optimalConditionProperty, "must be both less than and greater than", ?boundProperty)
]

// If OptimalCondition1 states some Property must be less than a Property bound, and OptimalCondition2 states that Property must
// be greater than or equal to that same Property bound, then these are conflicting OptimalConditions.
[ruleVer2s: (?aNode1 :withOptimalCondition ?optimalCondition1)
            (?optimalCondition1 rdf:type meta:OptimalCondition)
            (?optimalCondition1 ssn:forProperty ?optimalConditionProperty)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:lessThan)
            (?aNode2 :withOptimalCondition ?optimalCondition2)
            (?optimalCondition2 rdf:type meta:OptimalCondition)
            (?optimalCondition2 ssn:forProperty ?optimalConditionProperty)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:greaterThanOrEqualTo)
            notEqual(?optimalCondition1, ?optimalCondition2)
            ->  print("Error!")
                print("OptimalConditions", ?optimalCondition1, "and", ?optimalCondition2, "define conflicting constraints.")
                print(?optimalConditionProperty, "must be both less than and greater than or equal to", ?boundProperty)
]

// If OptimalCondition1 states some Property must be less than a Property bound, and OptimalCondition2 states that Property must
// be equal to that same Property bound, then these are conflicting OptimalConditions.
[ruleVer2t: (?aNode1 :withOptimalCondition ?optimalCondition1)
            (?optimalCondition1 rdf:type meta:OptimalCondition)
            (?optimalCondition1 ssn:forProperty ?optimalConditionProperty)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:lessThan)
            (?aNode2 :withOptimalCondition ?optimalCondition2)
            (?optimalCondition2 rdf:type meta:OptimalCondition)
            (?optimalCondition2 ssn:forProperty ?optimalConditionProperty)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:equalTo)
            notEqual(?optimalCondition1, ?optimalCondition2)
            ->  print("Error!")
                print("OptimalConditions", ?optimalCondition1, "and", ?optimalCondition2, "define conflicting constraints.")
                print(?optimalConditionProperty, "must be both less than and equal to", ?boundProperty)
]

// If OptimalCondition1 states some Property must be greater than a Property bound, and OptimalCondition2 states that Property must
// be equal to that same Property bound, then these are conflicting OptimalConditions.
[ruleVer2u: (?aNode1 :withOptimalCondition ?optimalCondition1)
            (?optimalCondition1 rdf:type meta:OptimalCondition)
            (?optimalCondition1 ssn:forProperty ?optimalConditionProperty)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:greaterThan)
            (?aNode2 :withOptimalCondition ?optimalCondition2)
            (?optimalCondition2 rdf:type meta:OptimalCondition)
            (?optimalCondition2 ssn:forProperty ?optimalConditionProperty)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:equalTo)
            notEqual(?optimalCondition1, ?optimalCondition2)
            ->  print("Error!")
                print("OptimalConditions", ?optimalCondition1, "and", ?optimalCondition2, "define conflicting constraints.")
                print(?optimalConditionProperty, "must be both greater than and equal to", ?boundProperty)
]

// If OptimalCondition1 states some Property must be greater than a Property bound, and OptimalCondition2 states that Property must
// be less than or equal to that same Property bound, then these are conflicting OptimalConditions.
[ruleVer2v: (?aNode1 :withOptimalCondition ?optimalCondition1)
            (?optimalCondition1 rdf:type meta:OptimalCondition)
            (?optimalCondition1 ssn:forProperty ?optimalConditionProperty)
            (?aNode1 owl:hasValue ?boundProperty)
            (?aNode1 owl:onProperty meta:greaterThan)
            (?aNode2 :withOptimalCondition ?optimalCondition2)
            (?optimalCondition2 rdf:type meta:OptimalCondition)
            (?optimalCondition2 ssn:forProperty ?optimalConditionProperty)
            (?aNode2 owl:hasValue ?boundProperty)
            (?aNode2 owl:onProperty meta:lessThanOrEqualTo)
            notEqual(?optimalCondition1, ?optimalCondition2)
            ->  print("Error!")
                print("OptimalConditions", ?optimalCondition1, "and", ?optimalCondition2, "define conflicting constraints.")
                print(?optimalConditionProperty, "must be both greater than and less than or equal to", ?boundProperty)
]



// Checks for a missing Actuator enacting the correct PropertyChange with the right Effect type for a given OptimalCondition Property.
[ruleVer3c: (?aNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?aNode :withPropertyChangeCheck ?effectType)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith ?effectType)
            noValue(?actuator meta:enacts ?propertyChange)
            ->  print("Error!")
                print("No existing Actuator/ConfigurableParameter enacts a PropertyChange causing a", ?effectType, "for Property")
                print(?optimalConditionProperty)
]