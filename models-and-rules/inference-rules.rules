@prefix : <http://www.semanticweb.org/ivans/ontologies/2025/instance-model-1#>.
@prefix meta: <http://www.semanticweb.org/ivans/ontologies/2025/ruleless-digital-twins/>.
@prefix ssn: <http://www.w3.org/ns/ssn/>.
@prefix sosa: <http://www.w3.org/ns/sosa/>.
@include <OWL>.
@include <verification-rules.rules>.
@include <user-rules.rules>.



// The following rules cover individuals with one or two value constraints. Once an OptimalCondition constraint
// has been located, a mark will be placed to allow subsequent rules to match and fire.

[rule1a:    (?individual rdf:type meta:OptimalCondition)
            (?individual ssn:forProperty ?property)
            (?individual rdf:type ?bNode1)
            (?bNode1 owl:onDataRange ?bNode2)
            (?bNode2 owl:withRestrictions ?bNode3)
            (?bNode3 rdf:first ?restriction)
            ->  (?restriction rdf:comment ?property)
                print()
                print("Marked a value restriction with Property", ?property)
                print() ]

[rule1b:    (?individual rdf:type meta:OptimalCondition)
            (?individual ssn:forProperty ?property)
            (?individual rdf:type ?bNode1)
            (?bNode1 owl:onDataRange ?bNode2)
            (?bNode2 owl:withRestrictions ?bNode3)
            (?bNode3 rdf:rest ?bNode4)
            (?bNode4 rdf:first ?restriction)
            ->  (?restriction rdf:comment ?property)
                print()
                print("Marked a value restriction with Property", ?property)
                print() ]

// These rules support disjunctive constraint definitions in OptimalConditions. E.g., (>15, <=20) or (>=24, <35).
// Such definitions cover cases whose Property values might fit in disjoint ranges. Currently, only 2 constraints
// are supported, but it is naturally possible to support more.

[rule1c:    (?individual rdf:type meta:OptimalCondition)
            (?individual ssn:forProperty ?property)
            (?individual rdf:type ?bNode1)
            (?bNode1 owl:onDataRange ?bNode2)
            (?bNode2 owl:unionOf ?bNode3)
            (?bNode3 rdf:first ?bNode4)
            (?bNode4 owl:withRestrictions ?bNode5)
            (?bNode5 rdf:first ?restriction)
            ->  (?restriction rdf:comment ?property)
                print()
                print("Marked a value restriction with Property", ?property)
                print() ]

[rule1d:    (?individual rdf:type meta:OptimalCondition)
            (?individual ssn:forProperty ?property)
            (?individual rdf:type ?bNode1)
            (?bNode1 owl:onDataRange ?bNode2)
            (?bNode2 owl:unionOf ?bNode3)
            (?bNode3 rdf:first ?bNode4)
            (?bNode4 owl:withRestrictions ?bNode5)
            (?bNode5 rdf:rest ?bNode6)
            (?bNode6 rdf:first ?restriction)
            ->  (?restriction rdf:comment ?property)
                print()
                print("Marked a value restriction with Property", ?property)
                print() ]

[rule1e:    (?individual rdf:type meta:OptimalCondition)
            (?individual ssn:forProperty ?property)
            (?individual rdf:type ?bNode1)
            (?bNode1 owl:onDataRange ?bNode2)
            (?bNode2 owl:unionOf ?bNode3)
            (?bNode3 rdf:rest ?bNode4)
            (?bNode4 rdf:first ?bNode5)
            (?bNode5 owl:withRestrictions ?bNode6)
            (?bNode6 rdf:first ?restriction)
            ->  (?restriction rdf:comment ?property)
                print()
                print("Marked a value restriction with Property", ?property)
                print() ]

[rule1f:    (?individual rdf:type meta:OptimalCondition)
            (?individual ssn:forProperty ?property)
            (?individual rdf:type ?bNode1)
            (?bNode1 owl:onDataRange ?bNode2)
            (?bNode2 owl:unionOf ?bNode3)
            (?bNode3 rdf:rest ?bNode4)
            (?bNode4 rdf:first ?bNode5)
            (?bNode5 owl:withRestrictions ?bNode6)
            (?bNode6 rdf:rest ?bNode7)
            (?bNode7 rdf:first ?restriction)
            ->  (?restriction rdf:comment ?property)
                print()
                print("Marked a value restriction with Property", ?property)
                print() ]



// Upon locating the marks for OptimalCondition constraints or optimization targets, these rules find the
// relevant PropertyChanges and use them for a temporary mark.

[rule2a:    (?bNode rdf:comment ?property)
            (?property meta:propertyFor ?propertyChange)
            (?propertyChange meta:affectsPropertyWith ?someChange)
            (?bNode owl:hasValue ?value)
            ->  (_: rdf:comment ?propertyChange)
                print()
                print("Located", ?propertyChange)
                print("as a relevant PropertyChange for the given constraint(s) on", ?property)
                print() ]

[rule2b:    (?restriction rdf:comment ?property)
            (?property meta:propertyFor ?propertyChange)
            (?propertyChange meta:affectsPropertyWith meta:ValueIncrease)
            (?restriction xsd:minExclusive ?value)
            ->  (_: rdf:comment ?propertyChange)
                print()
                print("Located", ?propertyChange)
                print("as a relevant PropertyChange for the given constraint(s) on", ?property)
                print() ]

[rule2c:    (?restriction rdf:comment ?property)
            (?property meta:propertyFor ?propertyChange)
            (?propertyChange meta:affectsPropertyWith meta:ValueIncrease)
            (?restriction xsd:minInclusive ?value)
            ->  (_: rdf:comment ?propertyChange)
                print()
                print("Located", ?propertyChange)
                print("as a relevant PropertyChange for the given constraint(s) on", ?property)
                print() ]

[rule2d:    (?restriction rdf:comment ?property)
            (?property meta:propertyFor ?propertyChange)
            (?propertyChange meta:affectsPropertyWith meta:ValueDecrease)
            (?restriction xsd:maxExclusive ?value)
            ->  (_: rdf:comment ?propertyChange)
                print()
                print("Located", ?propertyChange)
                print("as a relevant PropertyChange for the given constraint(s) on", ?property)
                print() ]

[rule2e:    (?restriction rdf:comment ?property)
            (?property meta:propertyFor ?propertyChange)
            (?propertyChange meta:affectsPropertyWith meta:ValueDecrease)
            (?restriction xsd:maxInclusive ?value)
            ->  (_: rdf:comment ?propertyChange)
                print()
                print("Located", ?propertyChange)
                print("as a relevant PropertyChange for the given constraint(s) on", ?property)
                print() ]



// The following rules locate PropertyChange marks and generate appropriate Actions, either with Actuators
// or ConfigurableParameters. URI concatinations are used for generating unique names for unique combinations of
// elements in an Action. This ensures that no duplicate Actions are generated in cases of, e.g., multiple
// actuators causing multiple different PropertyChanges.

[rule3a:    (?thing rdf:comment ?propertyChange)
            (?propertyChange meta:enactedBy ?actuator)
            (?actuator rdf:type sosa:Actuator)
            (?actuator meta:hasActuatorState ?actuatorState)
            uriConcat(?actuator, "_", ?actuatorState, ?actionName)
            ->  (?actionName rdf:type meta:ActuationAction)
                (?actionName meta:hasActuator ?actuator)
                (?actionName meta:hasActuatorState ?actuatorState)
                print()
                print("Generated ActuationAction", ?actionName)
                print() ]

[rule3b:    (?thing rdf:comment ?propertyChange)
            (?propertyChange meta:enactedBy ?configurableParameter)
            (?configurableParameter rdf:type meta:ConfigurableParameter)
            (?configurableParameter meta:hasValue ?configurableParameterValue)
            uriConcat(?configurableParameter, "_", ?configurableParameterValue, ?actionName)
            ->  (?actionName rdf:type meta:ReconfigurationAction)
                (?actionName ssn:forProperty ?configurableParameter)
                (?actionName meta:hasValue ?configurableParameterValue)
                print()
                print("Generated ReconfigurationAction", ?actionName)
                print() ]



// Something.

[rule4a:    (?actuationAction rdf:type meta:ActuationAction)
            (?actuationAction meta:hasActuator ?actuator)
            makeTemp(?actionCombination)
            makeTemp(?actionList)
            makeTemp(?actuatorList)
            ->  (?actionCombination rdf:type meta:ActionCombination)
                (?actionCombination rdf:comment "max size")
                (?actionCombination meta:hasActions ?actionList)
                (?actionList rdf:type rdf:List)
                (?actionList rdf:first ?actuationAction)
                (?actionList rdf:rest rdf:nil)
                (?actionCombination meta:hasActuators ?actuatorList)
                (?actuatorList rdf:type rdf:List)
                (?actuatorList rdf:first ?actuator)
                (?actuatorList rdf:rest rdf:nil) ]

[rule4b:    (?actionCombination rdf:type meta:ActionCombination)
            (?actionCombination meta:hasActions ?actionList)
            (?actionCombination meta:hasActuators ?actuatorList)
            (?actuationAction rdf:type meta:ActuationAction)
            (?actuationAction meta:hasActuator ?actuator)
            listNotContains(?actuatorList, ?actuator)
            makeTemp(?newActionCombination)
            makeTemp(?newActionList)
            makeTemp(?newActuatorList)
            ->  (?newActionCombination rdf:type meta:ActionCombination)
                (?newActionCombination rdf:comment "max size")
                (?newActionCombination meta:hasActions ?newActionList)
                (?newActionList rdf:type rdf:List)
                (?newActionList rdf:first ?actuationAction)
                (?newActionList rdf:rest ?actionList)
                (?newActionCombination meta:hasActuators ?newActuatorList)
                (?newActuatorList rdf:type rdf:List)
                (?newActuatorList rdf:first ?actuator)
                (?newActuatorList rdf:rest ?actuatorList) ]

[rule4c:    (?actionCombination1 rdf:type meta:ActionCombination)
            (?actionCombination1 rdf:comment "max size")
            (?actionCombination1 meta:hasActions ?actionList1)
            (?actionCombination2 rdf:type meta:ActionCombination)
            (?actionCombination2 rdf:comment "max size")
            (?actionCombination2 meta:hasActions ?actionList2)
            listLength(?actionList1, ?actionList1Length)
            listLength(?actionList2, ?actionList2Length)
            greaterThan(?actionList1Length, ?actionList2Length)
            ->  remove(4) ]

// instead of all combinations having max size by default, they should get it only when they reach max size. this way, it will be possible to flatten only the max sized ones into objects
// how to do this?
// we can first get the actuators before the actuation actions
// after that, we know the max size of the combinations, so we just need a rule for when a combination hits that size, then mark it as max size
// after that, we can try to flatten