@prefix : <http://www.semanticweb.org/ivans/ontologies/2025/instance-model-1#>.
@prefix meta: <http://www.semanticweb.org/ivans/ontologies/2025/ruleless-digital-twins/>.
@prefix ssn: <http://www.w3.org/ns/ssn/>.
@prefix sosa: <http://www.w3.org/ns/sosa/>.
@include <verification-rules.rules>.
@include <user-rules.rules>.



// Creates containers of information for evaluating atomic constraints in OptimalConditions.
[rule1a:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "true"^^xsd:boolean)
            (?aNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?optimalConditionProperty meta:hasValue ?optimalConditionPropertyValue)
            (?aNode owl:hasValue ?boundProperty)
            (?boundProperty meta:hasValue ?boundPropertyValue)
            (?aNode owl:onProperty ?operator)
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :withOperator ?operator)
                (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
                (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
                (?evaluationContainer :withAtomicConstraintContainer ?aNode)
]



// The following rules find atomic constraint information containers, evaluate them, and mark them with the result.

// If the comparison operator is equalTo (=) and the condition and bound Properties are equal, mark the container with a true evaluation result.
[rule2a:    (?evaluationContainer :withOperator meta:equalTo)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            equal(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "true"^^xsd:boolean)
]

// If the comparison operator is equalTo (=) and the condition Property is less than the bound Property, mark the container with a false
// evaluation result.
[rule2b:    (?evaluationContainer :withOperator meta:equalTo)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            lessThan(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "false"^^xsd:boolean)
]

// If the comparison operator is equalTo (=) and the condition Property is greater than the bound Property, mark the container with a false
// evaluation result.
[rule2c:    (?evaluationContainer :withOperator meta:equalTo)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            greaterThan(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "false"^^xsd:boolean)
]

// If the comparison operator is lessThan (<) and the condition Property is less than the bound Property, mark the container with a true
// evaluation result.
[rule2d:    (?evaluationContainer :withOperator meta:lessThan)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            lessThan(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "true"^^xsd:boolean)
]

// If the comparison operator is lessThan (<) and the condition Property is greater than or equal to the bound Property, mark the container
// with a false evaluation result.
[rule2e:    (?evaluationContainer :withOperator meta:lessThan)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            ge(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "false"^^xsd:boolean)
]

// If the comparison operator is lessThanOrEqualTo (<=) and the condition Property is less than or equal to the bound Property, mark the
// container with a true evaluation result.
[rule2f:    (?evaluationContainer :withOperator meta:lessThanOrEqualTo)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            le(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "true"^^xsd:boolean)
]

// If the comparison operator is lessThanOrEqualTo (<=) and the condition Property is greater than the bound Property, mark the container with
// a false evaluation result.
[rule2g:    (?evaluationContainer :withOperator meta:lessThanOrEqualTo)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            greaterThan(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "false"^^xsd:boolean)
]

// If the comparison operator is greaterThan (>) and the condition Property is greater than the bound Property, mark the container with a true
// evaluation result.
[rule2h:    (?evaluationContainer :withOperator meta:greaterThan)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            greaterThan(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "true"^^xsd:boolean)
]

// If the comparison operator is greaterThan (>) and the condition Property is less than or equal to the bound Property, mark the container
// with a false evaluation result.
[rule2i:    (?evaluationContainer :withOperator meta:greaterThan)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            le(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "false"^^xsd:boolean)
]

// If the comparison operator is greaterThanOrEqualTo (>=) and the condition Property is greater than or equal to the bound Property, mark the
// container with a true evaluation result.
[rule2j:    (?evaluationContainer :withOperator meta:greaterThanOrEqualTo)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            ge(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "true"^^xsd:boolean)
]

// If the comparison operator is greaterThanOrEqualTo (>=) and the condition Property is less than the bound Property, mark the container with
// a false evaluation result.
[rule2k:    (?evaluationContainer :withOperator meta:greaterThanOrEqualTo)
            (?evaluationContainer :withOptimalConditionPropertyValue ?optimalConditionPropertyValue)
            (?evaluationContainer :withBoundPropertyValue ?boundPropertyValue)
            (?evaluationContainer :withAtomicConstraintContainer ?aNode)
            lessThan(?optimalConditionPropertyValue, ?boundPropertyValue)
            ->  (?aNode :withEvaluationResult "false"^^xsd:boolean)
]



// The following rules add an evaluation result to a conjunctive constraint node based on the evaluations of its atomic constraints. This step
// simplifies further checks for whether an OptimalCondition is satisfied.

// If both conjunctive children evaluate to true, mark their shared ancestor node as true as well.
[rule3a:    (?aNode1 owl:intersectionOf ?aList)
            (?aList rdf:first ?aNode2)
            (?aNode2 rdf:type owl:Restriction)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withEvaluationResult "true"^^xsd:boolean)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 :withIdentifier ?identifier)
            (?aNode3 rdf:type owl:Restriction)
            (?aNode3 :withCheck "conjunction")
            (?aNode3 :withEvaluationResult "true"^^xsd:boolean)
            (?aNode3 :withOptimalCondition ?optimalCondition)
            (?aNode3 :withIdentifier ?identifier)
            ->  (?aNode1 :withEvaluationResult "true"^^xsd:boolean)
]

// If the first conjunctive child evaluates to false, mark the shared ancestor node as false.
[rule3b:    (?aNode1 owl:intersectionOf ?aList)
            (?aList rdf:first ?aNode2)
            (?aNode2 rdf:type owl:Restriction)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withEvaluationResult "true"^^xsd:boolean)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 :withIdentifier ?identifier)
            (?aNode3 rdf:type owl:Restriction)
            (?aNode3 :withCheck "conjunction")
            (?aNode3 :withEvaluationResult "false"^^xsd:boolean)
            (?aNode3 :withOptimalCondition ?optimalCondition)
            (?aNode3 :withIdentifier ?identifier)
            ->  (?aNode1 :withEvaluationResult "false"^^xsd:boolean)
]

// If the second conjunctive child evaluates to false, mark the shared ancestor node as false.
[rule3c:    (?aNode1 owl:intersectionOf ?aList)
            (?aList rdf:first ?aNode2)
            (?aNode2 rdf:type owl:Restriction)
            (?aNode2 :withCheck "conjunction")
            (?aNode2 :withEvaluationResult "false"^^xsd:boolean)
            (?aNode2 :withOptimalCondition ?optimalCondition)
            (?aNode2 :withIdentifier ?identifier)
            (?aNode3 rdf:type owl:Restriction)
            (?aNode3 :withCheck "conjunction")
            (?aNode3 :withEvaluationResult "true"^^xsd:boolean)
            (?aNode3 :withOptimalCondition ?optimalCondition)
            (?aNode3 :withIdentifier ?identifier)
            ->  (?aNode1 :withEvaluationResult "false"^^xsd:boolean)
]



// These rules mark OptimalConditions as enabled provided their respective enabling constraints evaluate to true.

// If the enabling constraint is a single constraint (e.g., >15) and it`s true, enable the OptimalCondition.
[rule4a:    (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition rdf:type ?aNode1)
            (?aNode1 rdf:type owl:Restriction)
            (?aNode1 owl:onProperty meta:hasEnablingConstraint)
            (?aNode1 owl:onClass ?aNode2)
            (?aNode2 :withEvaluationResult "true"^^xsd:boolean)
            ->  (?optimalCondition :isEnabled "true"^^xsd:boolean)
]

// If the enabling constraint is a conjunctive constraint (e.g., >15 and <22) and it`s true, enable the OptimalCondition.
[rule4b:    (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition rdf:type ?aNode1)
            (?aNode1 rdf:type owl:Restriction)
            (?aNode1 owl:onProperty meta:hasEnablingConstraint)
            (?aNode1 owl:onClass ?aNode2)
            (?aNode2 :withEvaluationResult "true"^^xsd:boolean)
            ->  (?optimalCondition :isEnabled "true"^^xsd:boolean)
]

// If the enabling constraint is a disjunctive constraint (e.g., <15 or >22) and it`s true, enable the OptimalCondition.
[rule4c:    (?aNode rdf:type owl:Restriction)
            (?aNode :withOptimalCondition ?optimalCondition)
            (?aNode :withConstraintType meta:hasEnablingConstraint)
            (?aNode :withCheck "disjunction")
            (?aNode :withEvaluationResult "true"^^xsd:boolean)
            noValue(?aNode :withCheck "conjunction")
            ->  (?optimalCondition :isEnabled "true"^^xsd:boolean)
]

// In case the OptimalCondition has no enabling constraints, it is enabled by default.
[rule4d:    (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition rdf:type ?aNode)
            (?aNode rdf:type owl:Restriction)
            noValue(?aNode owl:onProperty meta:hasEnablingConstraint)
            ->  (?optimalCondition :isEnabled "true"^^xsd:boolean)
]



// The following rules mark specific types of unsatisfied operators based on their evaluation result.

// All non-disjunctive constraints evaluating to false should generate mitigation Actions. Thus, their operators are marked as unsatisfied.
[rule5a:    (?aNode rdf:type owl:Restriction)
            (?aNode :withOptimalCondition ?optimalCondition)
            (?optimalCondition :isEnabled "true"^^xsd:boolean)
            (?aNode :withOptimalConditionProperty ?optimalConditionProperty)
            (?aNode :withConstraintType meta:hasConstraint)
            (?aNode :withOperatorCheck ?operator)
            (?aNode :withEvaluationResult "false"^^xsd:boolean)
            noValue(?aNode :withCheck "disjunction")
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
                (?evaluationContainer :withUnsatisfiedOperator ?operator)
]

// In case both sides of a disjunctive constraint evaluate to false, the OptimalCondition should generate mitigation Actions. Since
// disjunctive OptimalConditions only become unsatisfied if their condition Property is between the two range constraints, the
// OptimalCondition can be restored by both a ValueIncrease and a ValueDecrease on that Property. For simplicity, we therefore say
// that an equalTo is the unsatisfied operator.
[rule5b:    (?optimalCondition rdf:type meta:OptimalCondition)
            (?optimalCondition :isEnabled "true"^^xsd:boolean)
            (?optimalCondition rdf:type ?aNode1)
            (?optimalCondition ssn:forProperty ?optimalConditionProperty)
            (?aNode1 rdf:type owl:Restriction)
            (?aNode1 owl:onProperty meta:hasConstraint)
            (?aNode1 owl:onClass ?aNode2)
            (?aNode2 owl:unionOf ?aList1)
            (?aList1 rdf:first ?aNode3)
            (?aNode3 :withEvaluationResult "false"^^xsd:boolean)
            (?aList1 rdf:rest ?aList2)
            (?aList2 rdf:first ?aNode4)
            (?aNode4 :withEvaluationResult "false"^^xsd:boolean)
            makeTemp(?evaluationContainer)
            ->  (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
                (?evaluationContainer :withUnsatisfiedOperator meta:equalTo)
]



// The following rules match on unsatisfied operators and find PropertyChanges that will cause the respective Property value changes.

[rule6a:    (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
            (?evaluationContainer :withUnsatisfiedOperator meta:equalTo)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueIncrease)
            ->  (_: :withPropertyChange ?propertyChange)
]

[rule6b:    (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
            (?evaluationContainer :withUnsatisfiedOperator meta:equalTo)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueDecrease)
            ->  (_: :withPropertyChange ?propertyChange)
]

[rule6c:    (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
            (?evaluationContainer :withUnsatisfiedOperator meta:greaterThan)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueIncrease)
            ->  (_: :withPropertyChange ?propertyChange)
]

[rule6d:    (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
            (?evaluationContainer :withUnsatisfiedOperator meta:greaterThanOrEqualTo)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueIncrease)
            ->  (_: :withPropertyChange ?propertyChange)
]

[rule6e:    (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
            (?evaluationContainer :withUnsatisfiedOperator meta:lessThan)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueDecrease)
            ->  (_: :withPropertyChange ?propertyChange)
]

[rule6f:    (?evaluationContainer :withOptimalConditionProperty ?optimalConditionProperty)
            (?evaluationContainer :withUnsatisfiedOperator meta:lessThanOrEqualTo)
            (?propertyChange ssn:forProperty ?optimalConditionProperty)
            (?propertyChange meta:affectsPropertyWith meta:ValueDecrease)
            ->  (_: :withPropertyChange ?propertyChange)
]



// The following rules locate PropertyChange marks and generate appropriate Actions, either with Actuators or ConfigurableParameters. URI
// concatinations are used for generating unique names for unique combinations of elements in an Action. This ensures that no duplicate Actions
// are generated in cases of, e.g., multiple actuators causing multiple different PropertyChanges.

[rule7a:   (?thing :withPropertyChange ?propertyChange)
           (?actuator meta:enacts ?propertyChange)
           (?actuator rdf:type sosa:Actuator)
           (?actuator meta:hasActuatorState ?actuatorState)
           uriConcat(?actuator, "_", ?actuatorState, ?actionName)
           ->  (?actionName rdf:type meta:ActuationAction)
               (?actionName meta:hasActuator ?actuator)
               (?actionName meta:hasActuatorState ?actuatorState)
               print("Generated ActuationAction", ?actionName)
]

[rule7b:   (?thing :withPropertyChange ?propertyChange)
           (?configurableParameter meta:enacts ?propertyChange)
           (?configurableParameter rdf:type meta:ConfigurableParameter)
           (?configurableParameter meta:hasPossibleValue ?configurableParameterValue)
           uriConcat(?configurableParameter, "_", ?configurableParameterValue, ?actionName)
           ->  (?actionName rdf:type meta:ReconfigurationAction)
               (?actionName ssn:forProperty ?configurableParameter)
               (?actionName meta:hasValue ?configurableParameterValue)
               print("Generated ReconfigurationAction", ?actionName)
]

// The following rules generate Actions provided the switch for generating restrictive combinations (only based on unsatisfied OptimalConditions)
// is disabled.

[rule7c:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "false"^^xsd:boolean)
            (?actuator rdf:type sosa:Actuator)
            (?actuator meta:hasActuatorState ?actuatorState)
            uriConcat(?actuator, "_", ?actuatorState, ?actionName)
            ->  (?actionName rdf:type meta:ActuationAction)
                (?actionName meta:hasActuator ?actuator)
                (?actionName meta:hasActuatorState ?actuatorState)
                print("Generated ActuationAction", ?actionName)
]

[rule7d:    (?platform rdf:type sosa:Platform)
            (?platform meta:generateCombinationsOnlyFromOptimalConditions "false"^^xsd:boolean)
            (?configurableParameter rdf:type meta:ConfigurableParameter)
            (?configurableParameter meta:hasPossibleValue ?configurableParameterValue)
            uriConcat(?configurableParameter, "_", ?configurableParameterValue, ?actionName)
            ->  (?actionName rdf:type meta:ReconfigurationAction)
                (?actionName ssn:forProperty ?configurableParameter)
                (?actionName meta:hasValue ?configurableParameterValue)
                print("Generated ReconfigurationAction", ?actionName)
]



// The following rules infer possible combinations of Actions to take as part of the DT`s final decision. They effectively produce a
// cartesian product of a variable number of sets (Actions grouped by Actuators or ConfigurableParameters) with a variable number of
// elements (possible Actuator states or ConfigurableParameter values).
//
// The rules work by initially creating an ActionCombination for each Action found in the model (rules 4a and 4b). Every ActionCombination
// contains an rdf:List of Actions, which it then expands as it encounters new ones (rules 4c and 4d). To be added to the list, these Actions
// must not already be contained in it and their Actuators/ConfigurableParameters must not be the same as those of other Actions already
// in it. Because this method generates permutations (lists of the same Actions in different orders), additional rules (rules 4e and 4f)
// are necessary to eliminate duplicates and reduce the combinatorial explosion.
//
// In the end, all ActionCombinations that are NOT marked with "duplicate" (same combination already exists) or "not final" (the combination
// contains fewer Actions than it should) are final.

[rule8a:    (?actuationAction rdf:type meta:ActuationAction)
            (?actuationAction meta:hasActuator ?actuator)
            makeTemp(?actionCombination)
            makeTemp(?actionList)
            makeTemp(?actuatorList)
            ->  (?actionCombination rdf:type meta:ActionCombination)
                (?actionCombination meta:hasActions ?actionList)
                (?actionList rdf:type rdf:List)
                (?actionList rdf:first ?actuationAction)
                (?actionList rdf:rest rdf:nil)
                (?actionCombination meta:hasActuators ?actuatorList)
                (?actuatorList rdf:type rdf:List)
                (?actuatorList rdf:first ?actuator)
                (?actuatorList rdf:rest rdf:nil)
]

[rule8b:    (?reconfigurationAction rdf:type meta:ReconfigurationAction)
            (?reconfigurationAction ssn:forProperty ?configurableParameter)
            makeTemp(?actionCombination)
            makeTemp(?actionList)
            makeTemp(?configurableParameterList)
            ->  (?actionCombination rdf:type meta:ActionCombination)
                (?actionCombination meta:hasActions ?actionList)
                (?actionList rdf:type rdf:List)
                (?actionList rdf:first ?reconfigurationAction)
                (?actionList rdf:rest rdf:nil)
                (?actionCombination meta:hasConfigurableParameters ?configurableParameterList)
                (?configurableParameterList rdf:type rdf:List)
                (?configurableParameterList rdf:first ?configurableParameter)
                (?configurableParameterList rdf:rest rdf:nil)
]

[rule8c:    (?actionCombination rdf:type meta:ActionCombination)
            (?actionCombination meta:hasActions ?actionList)
            (?actionCombination meta:hasActuators ?actuatorList)
            (?actuationAction rdf:type meta:ActuationAction)
            (?actuationAction meta:hasActuator ?actuator)
            noValue(?actionCombination rdf:comment "duplicate")
            listNotContains(?actuatorList, ?actuator)
            makeTemp(?newActionCombination)
            makeTemp(?newActionList)
            makeTemp(?newActuatorList)
            ->  (?newActionCombination rdf:type meta:ActionCombination)
                (?newActionCombination meta:hasActions ?newActionList)
                (?newActionList rdf:type rdf:List)
                (?newActionList rdf:first ?actuationAction)
                (?newActionList rdf:rest ?actionList)
                (?newActionCombination meta:hasActuators ?newActuatorList)
                (?newActuatorList rdf:type rdf:List)
                (?newActuatorList rdf:first ?actuator)
                (?newActuatorList rdf:rest ?actuatorList)
                (?actionCombination rdf:comment "not final")
]

[rule8d:    (?actionCombination rdf:type meta:ActionCombination)
            (?actionCombination meta:hasActions ?actionList)
            (?actionCombination meta:hasConfigurableParameters ?configurableParameterList)
            (?reconfigurationAction rdf:type meta:ReconfigurationAction)
            (?reconfigurationAction ssn:forProperty ?configurableParameter)
            noValue(?actionCombination rdf:comment "duplicate")
            listNotContains(?configurableParameterList, ?configurableParameter)
            makeTemp(?newActionCombination)
            makeTemp(?newActionList)
            makeTemp(?newConfigurableParameterList)
            ->  (?newActionCombination rdf:type meta:ActionCombination)
                (?newActionCombination meta:hasActions ?newActionList)
                (?newActionList rdf:type rdf:List)
                (?newActionList rdf:first ?reconfigurationAction)
                (?newActionList rdf:rest ?actionList)
                (?newActionCombination meta:hasConfigurableParameters ?newConfigurableParameterList)
                (?newConfigurableParameterList rdf:type rdf:List)
                (?newConfigurableParameterList rdf:first ?configurableParameter)
                (?newConfigurableParameterList rdf:rest ?configurableParameterList)
                (?actionCombination rdf:comment "not final")
]

[rule8e:    (?actionCombination1 rdf:type meta:ActionCombination)
            (?actionCombination1 meta:hasActions ?actionList1)
            (?actionCombination2 rdf:type meta:ActionCombination)
            (?actionCombination2 meta:hasActions ?actionList2)
            notEqual(?actionCombination1, ?actionCombination2)
            noValue(?actionCombination1 rdf:comment "duplicate")
            noValue(?actionCombination2 rdf:comment "duplicate")
            listEqual(?actionList1, ?actionList2)
            ->  (?actionCombination2 rdf:comment "duplicate")
]